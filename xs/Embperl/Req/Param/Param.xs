
/*
 * *********** WARNING **************
 * This file generated by Embperl::WrapXS/2.0.0
 * Any changes made here will be lost
 * ***********************************
 * 1. /usr/lib/perl5/site_perl/5.16.0/ExtUtils/XSBuilder/WrapXS.pm:52
 * 2. /usr/lib/perl5/site_perl/5.16.0/ExtUtils/XSBuilder/WrapXS.pm:2068
 * 3. xsbuilder/xs_generate.pl:6
 */


#include "ep.h"

#include "epmacro.h"

#include "epdat2.h"

#include "eptypes.h"

#include "eppublic.h"

#include "EXTERN.h"

#include "perl.h"

#include "XSUB.h"

#include "ep_xs_sv_convert.h"

#include "ep_xs_typedefs.h"



void Embperl__Req__Param_destroy (pTHX_ Embperl__Req__Param  obj) {
            if (obj -> pCookies)
                SvREFCNT_dec(obj -> pCookies);
            if (obj -> pCGISV)
                SvREFCNT_dec(obj -> pCGISV);

};



void Embperl__Req__Param_new_init (pTHX_ Embperl__Req__Param  obj, SV * item, int overwrite) {

    SV * * tmpsv ;

    if (SvTYPE(item) == SVt_PVMG) 
        memcpy (obj, (void *)SvIVX(item), sizeof (*obj)) ;
    else if (SvTYPE(item) == SVt_PVHV) {
        if ((tmpsv = hv_fetch((HV *)item, "filename", sizeof("filename") - 1, 0)) || overwrite) {
            char * tmpobj = ((char *)epxs_sv2_PV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)));
            if (tmpobj)
                obj -> sFilename = (char *)ep_pstrdup(obj->pPool,tmpobj);
            else
                obj -> sFilename = NULL ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "unparsed_uri", sizeof("unparsed_uri") - 1, 0)) || overwrite) {
            char * tmpobj = ((char *)epxs_sv2_PV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)));
            if (tmpobj)
                obj -> sUnparsedUri = (char *)ep_pstrdup(obj->pPool,tmpobj);
            else
                obj -> sUnparsedUri = NULL ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "uri", sizeof("uri") - 1, 0)) || overwrite) {
            char * tmpobj = ((char *)epxs_sv2_PV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)));
            if (tmpobj)
                obj -> sUri = (char *)ep_pstrdup(obj->pPool,tmpobj);
            else
                obj -> sUri = NULL ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "server_addr", sizeof("server_addr") - 1, 0)) || overwrite) {
            char * tmpobj = ((char *)epxs_sv2_PV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)));
            if (tmpobj)
                obj -> sServerAddr = (char *)ep_pstrdup(obj->pPool,tmpobj);
            else
                obj -> sServerAddr = NULL ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "path_info", sizeof("path_info") - 1, 0)) || overwrite) {
            char * tmpobj = ((char *)epxs_sv2_PV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)));
            if (tmpobj)
                obj -> sPathInfo = (char *)ep_pstrdup(obj->pPool,tmpobj);
            else
                obj -> sPathInfo = NULL ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "query_info", sizeof("query_info") - 1, 0)) || overwrite) {
            char * tmpobj = ((char *)epxs_sv2_PV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)));
            if (tmpobj)
                obj -> sQueryInfo = (char *)ep_pstrdup(obj->pPool,tmpobj);
            else
                obj -> sQueryInfo = NULL ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "language", sizeof("language") - 1, 0)) || overwrite) {
            char * tmpobj = ((char *)epxs_sv2_PV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)));
            if (tmpobj)
                obj -> sLanguage = (char *)ep_pstrdup(obj->pPool,tmpobj);
            else
                obj -> sLanguage = NULL ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "cookies", sizeof("cookies") - 1, 0)) || overwrite) {
            HV * tmpobj = ((HV *)epxs_sv2_HVREF((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)));
            if (tmpobj)
                obj -> pCookies = (HV *)SvREFCNT_inc(tmpobj);
            else
                obj -> pCookies = NULL ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "cgi", sizeof("cgi") - 1, 0)) || overwrite) {
            SV * tmpobj = ((SV *)epxs_sv2_SVPTR((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)));
            if (tmpobj)
                obj -> pCGISV = (SV *)SvREFCNT_inc(tmpobj);
            else
                obj -> pCGISV = NULL ;
        }
   ; }

    else
        croak ("initializer for Embperl::Req::Param::new is not a hash or object reference") ;

} ;


MODULE = Embperl::Req::Param    PACKAGE = Embperl::Req::Param 

char *
filename(obj, val=NULL)
    Embperl::Req::Param obj
    char * val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (char *)  obj->sFilename;

    if (items > 1) {
        obj->sFilename = (char *)ep_pstrdup(obj->pPool,val);
    }
  OUTPUT:
    RETVAL

MODULE = Embperl::Req::Param    PACKAGE = Embperl::Req::Param 

char *
unparsed_uri(obj, val=NULL)
    Embperl::Req::Param obj
    char * val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (char *)  obj->sUnparsedUri;

    if (items > 1) {
        obj->sUnparsedUri = (char *)ep_pstrdup(obj->pPool,val);
    }
  OUTPUT:
    RETVAL

MODULE = Embperl::Req::Param    PACKAGE = Embperl::Req::Param 

char *
uri(obj, val=NULL)
    Embperl::Req::Param obj
    char * val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (char *)  obj->sUri;

    if (items > 1) {
        obj->sUri = (char *)ep_pstrdup(obj->pPool,val);
    }
  OUTPUT:
    RETVAL

MODULE = Embperl::Req::Param    PACKAGE = Embperl::Req::Param 

char *
server_addr(obj, val=NULL)
    Embperl::Req::Param obj
    char * val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (char *)  obj->sServerAddr;

    if (items > 1) {
        obj->sServerAddr = (char *)ep_pstrdup(obj->pPool,val);
    }
  OUTPUT:
    RETVAL

MODULE = Embperl::Req::Param    PACKAGE = Embperl::Req::Param 

char *
path_info(obj, val=NULL)
    Embperl::Req::Param obj
    char * val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (char *)  obj->sPathInfo;

    if (items > 1) {
        obj->sPathInfo = (char *)ep_pstrdup(obj->pPool,val);
    }
  OUTPUT:
    RETVAL

MODULE = Embperl::Req::Param    PACKAGE = Embperl::Req::Param 

char *
query_info(obj, val=NULL)
    Embperl::Req::Param obj
    char * val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (char *)  obj->sQueryInfo;

    if (items > 1) {
        obj->sQueryInfo = (char *)ep_pstrdup(obj->pPool,val);
    }
  OUTPUT:
    RETVAL

MODULE = Embperl::Req::Param    PACKAGE = Embperl::Req::Param 

char *
language(obj, val=NULL)
    Embperl::Req::Param obj
    char * val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (char *)  obj->sLanguage;

    if (items > 1) {
        obj->sLanguage = (char *)ep_pstrdup(obj->pPool,val);
    }
  OUTPUT:
    RETVAL

MODULE = Embperl::Req::Param    PACKAGE = Embperl::Req::Param 

HV *
cookies(obj, val=NULL)
    Embperl::Req::Param obj
    HV * val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (HV *)  obj->pCookies;

    if (items > 1) {
        obj->pCookies = (HV *)SvREFCNT_inc(val);
    }
  OUTPUT:
    RETVAL

MODULE = Embperl::Req::Param    PACKAGE = Embperl::Req::Param 

SV *
cgi(obj, val=NULL)
    Embperl::Req::Param obj
    SV * val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (SV *)  obj->pCGISV;

    if (items > 1) {
        obj->pCGISV = (SV *)SvREFCNT_inc(val);
    }
  OUTPUT:
    RETVAL

MODULE = Embperl::Req::Param    PACKAGE = Embperl::Req::Param 



SV *
new (class,initializer=NULL)
    char * class
    SV * initializer 
PREINIT:
    SV * svobj ;
    Embperl__Req__Param  cobj ;
    SV * tmpsv ;
CODE:
    epxs_Embperl__Req__Param_create_obj(cobj,svobj,RETVAL,malloc(sizeof(*cobj))) ;

    if (initializer) {
        if (!SvROK(initializer) || !(tmpsv = SvRV(initializer))) 
            croak ("initializer for Embperl::Req::Param::new is not a reference") ;

        if (SvTYPE(tmpsv) == SVt_PVHV || SvTYPE(tmpsv) == SVt_PVMG)  
            Embperl__Req__Param_new_init (aTHX_ cobj, tmpsv, 0) ;
        else if (SvTYPE(tmpsv) == SVt_PVAV) {
            int i ;
            SvGROW(svobj, sizeof (*cobj) * av_len((AV *)tmpsv)) ;     
            for (i = 0; i <= av_len((AV *)tmpsv); i++) {
                SV * * itemrv = av_fetch((AV *)tmpsv, i, 0) ;
                SV * item ;
                if (!itemrv || !*itemrv || !SvROK(*itemrv) || !(item = SvRV(*itemrv))) 
                    croak ("array element of initializer for Embperl::Req::Param::new is not a reference") ;
                Embperl__Req__Param_new_init (aTHX_ &cobj[i], item, 1) ;
            }
        }
        else {
             croak ("initializer for Embperl::Req::Param::new is not a hash/array/object reference") ;
        }
    }
OUTPUT:
    RETVAL 

MODULE = Embperl::Req::Param    PACKAGE = Embperl::Req::Param 



void
DESTROY (obj)
    Embperl::Req::Param  obj 
CODE:
    Embperl__Req__Param_destroy (aTHX_ obj) ;

PROTOTYPES: disabled

BOOT:
    items = items; /* -Wall */

